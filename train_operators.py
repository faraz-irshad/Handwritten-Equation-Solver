"""
Train an operator CNN using synthetic data generated by data_gen.py
"""
import torch
from torch import nn, optim
from torch.utils.data import DataLoader, Dataset
from torchvision import transforms
from PIL import Image
from pathlib import Path
from models import SimpleCNN
import numpy as np

DATA_DIR = Path(__file__).parent / 'data' / 'operators'


class OperatorDataset(Dataset):
    def __init__(self, root=DATA_DIR, transform=None):
        self.samples = []
        self.labels = []
        self.classes = sorted([p.name for p in root.iterdir() if p.is_dir()])
        for idx, c in enumerate(self.classes):
            for f in (root / c).glob('*.png'):
                self.samples.append(f)
                self.labels.append(idx)
        self.transform = transform or transforms.Compose([transforms.Resize((64,64)), transforms.ToTensor()])

    def __len__(self):
        return len(self.samples)

    def __getitem__(self, idx):
        p = self.samples[idx]
        img = Image.open(p).convert('L')
        img = self.transform(img)
        label = self.labels[idx]
        return img, label


def train(save_path='models/op_cnn.pth', epochs=8, batch_size=64, device='cpu'):
    ds = OperatorDataset()
    # Save class mapping for inference
    try:
        import json
        (Path(save_path).parent).mkdir(parents=True, exist_ok=True)
        with open(Path(save_path).parent / 'op_classes.json', 'w', encoding='utf8') as fh:
            json.dump(ds.classes, fh, ensure_ascii=False)
    except Exception:
        pass
    loader = DataLoader(ds, batch_size=batch_size, shuffle=True)
    model = SimpleCNN(out_classes=len(ds.classes)).to(device)
    criterion = nn.CrossEntropyLoss()
    opt = optim.Adam(model.parameters(), lr=1e-3)
    for epoch in range(epochs):
        model.train()
        total_loss = 0
        for imgs, labels in loader:
            imgs = imgs.to(device)
            labels = labels.to(device)
            opt.zero_grad()
            out = model(imgs)
            loss = criterion(out, labels)
            loss.backward()
            opt.step()
            total_loss += loss.item()
        print(f"Epoch {epoch+1}/{epochs} loss={total_loss/len(loader):.4f}")
    Path(save_path).parent.mkdir(parents=True, exist_ok=True)
    torch.save(model.state_dict(), save_path)
    print("Saved operator model to", save_path)


if __name__ == '__main__':
    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print(f"Using device: {device}")
    train(epochs=4, device=device)
